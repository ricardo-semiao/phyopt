[{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using the Phy Algorithm","text":"article, introduce use optimize_phy() function. ’ll work two examples, one trivial, one much. Consider also seeing vignette(\"theoretical_framework\", package = \"phyopt\") article theoretical background algorithm. problem interest : \\[ \\begin{array}{lr}     \\min_{x, \\tilde{x}} x^2 + \\tilde{x}^2 ~~s.t.~~ \\tilde{x} - 2 \\geq 0,\\\\     X = \\tilde{X} = [-10, 10] \\end{array} \\] First, lets load package: ’ll also set objects , explain later.","code":"#> Loading required package: purrr #> Loading required package: rlang #> #> Attaching package: 'rlang' #> The following objects are masked from 'package:purrr': #> #>     %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl, #>     flatten_raw, invoke, splice stopper <- flow_stopper(list(max_iter = t ~ .m >= 20)) logger <- flow_logger()"},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Using the Phy Algorithm","text":"problem interest : \\[ \\begin{array}{lr}     \\min_{x, \\tilde{x}} x^2 + \\tilde{x}^2 ~~s.t.~~ \\tilde{x} - 2 \\geq 0,\\\\     X = \\tilde{X} = [-10, 10] \\end{array} \\] First, lets load package: ’ll also set objects , explain later.","code":"#> Loading required package: purrr #> Loading required package: rlang #> #> Attaching package: 'rlang' #> The following objects are masked from 'package:purrr': #> #>     %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl, #>     flatten_raw, invoke, splice stopper <- flow_stopper(list(max_iter = t ~ .m >= 20)) logger <- flow_logger()"},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"solving-the-example","dir":"Articles","previous_headings":"","what":"Solving The Example","title":"Using the Phy Algorithm","text":"First, lets define mathematical objects problem: format x_dom? different. end, whichever format useful way ’ll define operators. Lets get , problem, ’ll choose random (uniform) sampler initialization, golden search optimization, genetic algorithm’s approach crossover+mutation updater. ’ve different choice, user can even mix match choices. numbers samples \\(N\\) fixed \\(10\\), ’ll set beginning. , consider example random sampler, resamples draw fails constraint: Note arguments must exactly (names). result required \\(X \\times \\tilde{m}\\) matrix: Now, lets golden search optimizer. Se Wikipedia page learn . , arguments names required. denote optimizer run every sample \\(xtil_s\\) current population \\(S_t\\). functions f_s g_s receive values : Note required data frame format. Also note (.) used create matrix column. knew data frames matrices columns? See section [Advanced R (2e)](https://adv-r.hadley.nz/vectors-chap.html?q=(#matrix--data-frame-columns) information. neat trick enables elegant use flow_* formulas evaluation. Also note one create optimizer randomly chooses list optimizers, use different ones time, sensitivity reasons. Lets join . simple terms, algorithm initializes : , enters loop (emulated t <- 1 first iteration), creates xtil_t (\\(S_t\\)) variable. , sample \\(s\\) loop via map (, see Advanced R), save 1-row data frames list. list ‘rbinded’ via list_rbind. See turns : Note matrices columns. case hard differentiate 1-column matrices, accommodate dimension \\(m\\) \\(\\tilde{m}\\). See full results : Now lets move forward, define genetic algorithm approach update sample. sort \\(S_t\\) based lowest values \\(f\\) decreasing = FALSE, looking minimum. , select pairs values, greater probability lower values. used create “child”, “mutated” random multiplicative noise. Finally, constraint checked triggers resampling needed. , fixed argument names matrix result. See output : ingredients combined optimize_phy function, also tests : functions correct arguments. domains correct length. operators correct arguments generate results correct format. Catches errors operators calls help debug code. Calculates metrics check performance, log console, stop algorithm reaches desired value. Lets talk flow_stopper flow_logger. See full help page details, flow_stopper recives list : element formula, expression LHS can access results point, ie: current iteration t time. sequences f (\\(t \\times 1\\) vector) iterations. sequence x (\\(t \\times m\\) matrix) x (\\(t \\times \\tilde{m}\\) matrix). sequence meta-information , whichever format made . , user can define metric wants. expression evaluated current context algorithm, via non-standard evaluation (, Advanced R, yes, favorite R book, knew?), using columns \\(results_t\\) variables (hence beauty matrix-columns). , RHS expression takes value metric .m returns single boolean. Finally, check_expr expression gets vector booleans (.ms) combines logical expression single boolean, TRUE algorithm stopped. allows stopping algorithm group metrics true. flow_logger similar, can also access metrics calculated variables (hence names list ), RHS function formats .m single string. Lets set . stopping criteria reaching 20 iterations. objects comprised elements used algorithm: Lets run ! can get duration, stopping criterias met, \\(R_t\\) \\(M_t\\), including best (last): can see got close global minimum \\((0, 2)\\). efficacy due number iters user code.","code":"f <- \\(x, xtil) x^2 + xtil^2 g <- \\(x, xtil) 0 gtil <- \\(xtil) xtil - 2  x_dom <- xtil_dom <- list(c(-10, 10)) n_samples <- 10  initializer <- function(xtil_dom, gtil) {   xtil <- rep(NA, n_samples)      for (s in seq_len(n_samples)) {     draw <- NA     while (is.na(draw)) {       draw <- runif(1, xtil_dom[[1]][1], xtil_dom[[1]][2])       draw <- ifelse(gtil(draw) >= 0, yes = draw, no = NA)     }     xtil[s] <- draw   }    matrix(xtil, n_samples, 1) } initializer(xtil_dom, gtil) #>           [,1] #>  [1,] 6.813880 #>  [2,] 2.164976 #>  [3,] 2.112806 #>  [4,] 7.712842 #>  [5,] 2.380752 #>  [6,] 7.748516 #>  [7,] 5.462304 #>  [8,] 3.493641 #>  [9,] 9.921412 #> [10,] 6.289450 optimizer <- function(f_s, g_s, x_dom, t, xtil_s) {   phi <- 2 / (sqrt(5) + 1)    a <- x_dom[[1]][1];  b <- x_dom[[1]][2]   x1 <- b - phi * (b - a);  x2 <- a + phi * (b - a)   fx1 <- f_s(x1);  fx2 <- f_s(x2)    iter <- 0    while (abs(b - a) > 1e-5 && iter < 1000) {     if (fx1 < fx2) {       b <- x2       x2 <- x1; fx2 <- fx1       x1 <- b - phi * (b - a)       fx1 <- f_s(x1)     } else {       a <- x1       x1 <- x2; fx1 <- fx2       x2 <- a + phi * (b - a)       fx2 <- f_s(x2)     }     iter <- iter + 1   }    x <- (a + b) / 2   data.frame(x = I(matrix(x)), xtil = I(matrix(xtil_s)), f = f_s(x), i = NA) } xtil_s <- 5 f_s <- \\(x) f(x, xtil_s) g_s <- \\(x) g(x, xtil_s)  optimizer(f_s = f_s, g_s = g_s, x_dom = x_dom, t = 5, xtil_s = xtil_s) #>              x xtil  f  i #> 1 2.053031e-06    5 25 NA results <- vector(\"list\", length(stopper$iter_upper))  results[[1]]$xtil <- initializer(xtil_dom, gtil) t <- 1 xtil_t <- results[[t]]$xtil  results[[t]] <- list_rbind(map(seq_len(nrow(xtil_t)), function(s) {   xtil_s <- xtil_t[s, ]   f_s <- \\(x) f(x, xtil_s)   g_s <- \\(x) g(x, xtil_s)   optimizer(f_s = f_s, g_s = g_s, x_dom = x_dom, t = t, xtil_s = xtil_s) })) str(results[[t]]) #> 'data.frame':    10 obs. of  4 variables: #>  $ x   : 'AsIs' num [1:10, 1] 2.05e-06 2.05e-06 2.05e-06 2.05e-06 2.05e-06 ... #>  $ xtil: 'AsIs' num [1:10, 1] 2.81 7.15 2.02 8.51 9.55 ... #>  $ f   : num  7.88 51.13 4.09 72.47 91.21 ... #>  $ i   : logi  NA NA NA NA NA NA ... results[[t]] #>               x     xtil         f  i #> 1  2.053031e-06 2.807175  7.880233 NA #> 2  2.053031e-06 7.150618 51.131331 NA #> 3  2.053031e-06 2.021987  4.088432 NA #> 4  2.053031e-06 8.512952 72.470351 NA #> 5  2.053031e-06 9.550400 91.210139 NA #> 6  2.053031e-06 3.068233  9.414057 NA #> 7  2.053031e-06 4.526384 20.488148 NA #> 8  2.053031e-06 7.739593 59.901302 NA #> 9  2.053031e-06 3.600842 12.966066 NA #> 10 2.053031e-06 5.891748 34.712697 NA updater <- function(xtil_dom, gtil, r_t, t) {   xtil_ordered <- r_t$xtil[order(r_t$f, decreasing = FALSE), 1]   xtil_new <- matrix(NA, nrow = n_samples, ncol = 1)    probs <- 1 / (1:n_samples)   probs <- probs / sum(probs)    for (s in seq_len(n_samples)) {     draw <- NA     while (is.na(draw)) {       parents <- sample(n_samples, 2, prob = probs)       draw <- (xtil_ordered[parents[1]] + xtil_ordered[parents[2]]) / 2       draw <- draw * (1 + runif(1, -0.1, 0.1))       draw <- ifelse(gtil(draw) >= 0, draw, NA)     }     xtil_new[s, 1] <- draw   }    xtil_new } updater(xtil_dom = xtil_dom, gtil = gtil, r_t = results[[t]], t = t) #>           [,1] #>  [1,] 2.332980 #>  [2,] 2.440163 #>  [3,] 2.989183 #>  [4,] 3.171776 #>  [5,] 2.571547 #>  [6,] 7.408724 #>  [7,] 3.580395 #>  [8,] 6.763632 #>  [9,] 3.803764 #> [10,] 5.619331 list(   max_iter = t ~ .m >= 20,   max_time = time ~ .m >= 600,   f_prop = (max(f[[t]]) - max(f[[t - l]])) / abs(max(f[[t - 1]])) ~ .m < 0.01 ) stopper <- flow_stopper(list(max_iter = t ~ .m >= 20)) logger <- flow_logger() str(stopper) #> List of 3 #>  $ iter_upper   : num 10000 #>  $ get_metrics  :function (results, t, time)   #>  $ check_metrics:function (metrics_t, which = FALSE)   #>  - attr(*, \"class\")= chr \"flow_stopper\" str(logger) #> List of 1 #>  $ log:function (results_t, t, time, metrics_t)   #>  - attr(*, \"class\")= chr \"flow_logger\" optima <- optimize_phy(   f, g, gtil,   x_dom, xtil_dom,   initializer, optimizer, updater,   stopper, logger,   check_op = 0 ) #> → => Iter: 1 -- mean(f): 31.2683 #> → => Iter: 2 -- mean(f): 11.7562 #> → => Iter: 3 -- mean(f): 6.82 #> → => Iter: 4 -- mean(f): 6.4342 #> → => Iter: 5 -- mean(f): 6.3033 #> → => Iter: 6 -- mean(f): 6.0057 #> → => Iter: 7 -- mean(f): 5.855 #> → => Iter: 8 -- mean(f): 5.7328 #> → => Iter: 9 -- mean(f): 5.2253 #> → => Iter: 10 -- mean(f): 5.1215 #> → => Iter: 11 -- mean(f): 4.8846 #> → => Iter: 12 -- mean(f): 4.9285 #> → => Iter: 13 -- mean(f): 4.6471 #> → => Iter: 14 -- mean(f): 4.785 #> → => Iter: 15 -- mean(f): 4.7541 #> → => Iter: 16 -- mean(f): 4.5084 #> → => Iter: 17 -- mean(f): 4.72 #> → => Iter: 18 -- mean(f): 4.6569 #> → => Iter: 19 -- mean(f): 4.6255 #> → => Iter: 20 -- mean(f): 4.6122 #>  #> ✔ Finished after 20 iterations. Stopping criteria(s) were: #> • max_iter: t ~ .m >= 20 str(optima, 1) #> List of 4 #>  $ results     :List of 20 #>  $ metrics     :List of 20 #>  $ metrics_stop: Named chr \"max_iter: t ~ .m >= 20\" #>   ..- attr(*, \"names\")= chr \"max_iter\" #>  $ duration    :List of 4 optima$duration #> $iters #> [1] 20 #>  #> $time_init #> Time difference of 0.01880693 secs #>  #> $time_loop #> Time difference of 1.614986 secs #>  #> $time_total #> Time difference of 1.633796 secs optima$metrics_stop #>                 max_iter  #> \"max_iter: t ~ .m >= 20\" r_t <- optima$results[[20]] r_t[which.max(r_t$f), ] #>              x     xtil        f  i #> 5 2.053031e-06 2.259283 5.104362 NA"},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"initializer","dir":"Articles","previous_headings":"","what":"Initializer","title":"Using the Phy Algorithm","text":"numbers samples \\(N\\) fixed \\(10\\), ’ll set beginning. , consider example random sampler, resamples draw fails constraint: Note arguments must exactly (names). result required \\(X \\times \\tilde{m}\\) matrix:","code":"n_samples <- 10  initializer <- function(xtil_dom, gtil) {   xtil <- rep(NA, n_samples)      for (s in seq_len(n_samples)) {     draw <- NA     while (is.na(draw)) {       draw <- runif(1, xtil_dom[[1]][1], xtil_dom[[1]][2])       draw <- ifelse(gtil(draw) >= 0, yes = draw, no = NA)     }     xtil[s] <- draw   }    matrix(xtil, n_samples, 1) } initializer(xtil_dom, gtil) #>           [,1] #>  [1,] 6.813880 #>  [2,] 2.164976 #>  [3,] 2.112806 #>  [4,] 7.712842 #>  [5,] 2.380752 #>  [6,] 7.748516 #>  [7,] 5.462304 #>  [8,] 3.493641 #>  [9,] 9.921412 #> [10,] 6.289450"},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"optimizer","dir":"Articles","previous_headings":"","what":"Optimizer","title":"Using the Phy Algorithm","text":"Now, lets golden search optimizer. Se Wikipedia page learn . , arguments names required. denote optimizer run every sample \\(xtil_s\\) current population \\(S_t\\). functions f_s g_s receive values : Note required data frame format. Also note (.) used create matrix column. knew data frames matrices columns? See section [Advanced R (2e)](https://adv-r.hadley.nz/vectors-chap.html?q=(#matrix--data-frame-columns) information. neat trick enables elegant use flow_* formulas evaluation. Also note one create optimizer randomly chooses list optimizers, use different ones time, sensitivity reasons.","code":"optimizer <- function(f_s, g_s, x_dom, t, xtil_s) {   phi <- 2 / (sqrt(5) + 1)    a <- x_dom[[1]][1];  b <- x_dom[[1]][2]   x1 <- b - phi * (b - a);  x2 <- a + phi * (b - a)   fx1 <- f_s(x1);  fx2 <- f_s(x2)    iter <- 0    while (abs(b - a) > 1e-5 && iter < 1000) {     if (fx1 < fx2) {       b <- x2       x2 <- x1; fx2 <- fx1       x1 <- b - phi * (b - a)       fx1 <- f_s(x1)     } else {       a <- x1       x1 <- x2; fx1 <- fx2       x2 <- a + phi * (b - a)       fx2 <- f_s(x2)     }     iter <- iter + 1   }    x <- (a + b) / 2   data.frame(x = I(matrix(x)), xtil = I(matrix(xtil_s)), f = f_s(x), i = NA) } xtil_s <- 5 f_s <- \\(x) f(x, xtil_s) g_s <- \\(x) g(x, xtil_s)  optimizer(f_s = f_s, g_s = g_s, x_dom = x_dom, t = 5, xtil_s = xtil_s) #>              x xtil  f  i #> 1 2.053031e-06    5 25 NA"},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"joining-the-pieces","dir":"Articles","previous_headings":"","what":"Joining The Pieces","title":"Using the Phy Algorithm","text":"Lets join . simple terms, algorithm initializes : , enters loop (emulated t <- 1 first iteration), creates xtil_t (\\(S_t\\)) variable. , sample \\(s\\) loop via map (, see Advanced R), save 1-row data frames list. list ‘rbinded’ via list_rbind. See turns : Note matrices columns. case hard differentiate 1-column matrices, accommodate dimension \\(m\\) \\(\\tilde{m}\\). See full results :","code":"results <- vector(\"list\", length(stopper$iter_upper))  results[[1]]$xtil <- initializer(xtil_dom, gtil) t <- 1 xtil_t <- results[[t]]$xtil  results[[t]] <- list_rbind(map(seq_len(nrow(xtil_t)), function(s) {   xtil_s <- xtil_t[s, ]   f_s <- \\(x) f(x, xtil_s)   g_s <- \\(x) g(x, xtil_s)   optimizer(f_s = f_s, g_s = g_s, x_dom = x_dom, t = t, xtil_s = xtil_s) })) str(results[[t]]) #> 'data.frame':    10 obs. of  4 variables: #>  $ x   : 'AsIs' num [1:10, 1] 2.05e-06 2.05e-06 2.05e-06 2.05e-06 2.05e-06 ... #>  $ xtil: 'AsIs' num [1:10, 1] 2.81 7.15 2.02 8.51 9.55 ... #>  $ f   : num  7.88 51.13 4.09 72.47 91.21 ... #>  $ i   : logi  NA NA NA NA NA NA ... results[[t]] #>               x     xtil         f  i #> 1  2.053031e-06 2.807175  7.880233 NA #> 2  2.053031e-06 7.150618 51.131331 NA #> 3  2.053031e-06 2.021987  4.088432 NA #> 4  2.053031e-06 8.512952 72.470351 NA #> 5  2.053031e-06 9.550400 91.210139 NA #> 6  2.053031e-06 3.068233  9.414057 NA #> 7  2.053031e-06 4.526384 20.488148 NA #> 8  2.053031e-06 7.739593 59.901302 NA #> 9  2.053031e-06 3.600842 12.966066 NA #> 10 2.053031e-06 5.891748 34.712697 NA"},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"updater","dir":"Articles","previous_headings":"","what":"Updater","title":"Using the Phy Algorithm","text":"Now lets move forward, define genetic algorithm approach update sample. sort \\(S_t\\) based lowest values \\(f\\) decreasing = FALSE, looking minimum. , select pairs values, greater probability lower values. used create “child”, “mutated” random multiplicative noise. Finally, constraint checked triggers resampling needed. , fixed argument names matrix result. See output :","code":"updater <- function(xtil_dom, gtil, r_t, t) {   xtil_ordered <- r_t$xtil[order(r_t$f, decreasing = FALSE), 1]   xtil_new <- matrix(NA, nrow = n_samples, ncol = 1)    probs <- 1 / (1:n_samples)   probs <- probs / sum(probs)    for (s in seq_len(n_samples)) {     draw <- NA     while (is.na(draw)) {       parents <- sample(n_samples, 2, prob = probs)       draw <- (xtil_ordered[parents[1]] + xtil_ordered[parents[2]]) / 2       draw <- draw * (1 + runif(1, -0.1, 0.1))       draw <- ifelse(gtil(draw) >= 0, draw, NA)     }     xtil_new[s, 1] <- draw   }    xtil_new } updater(xtil_dom = xtil_dom, gtil = gtil, r_t = results[[t]], t = t) #>           [,1] #>  [1,] 2.332980 #>  [2,] 2.440163 #>  [3,] 2.989183 #>  [4,] 3.171776 #>  [5,] 2.571547 #>  [6,] 7.408724 #>  [7,] 3.580395 #>  [8,] 6.763632 #>  [9,] 3.803764 #> [10,] 5.619331"},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"the-optimize_phy-aggregation","dir":"Articles","previous_headings":"","what":"The optimize_phy Aggregation","title":"Using the Phy Algorithm","text":"ingredients combined optimize_phy function, also tests : functions correct arguments. domains correct length. operators correct arguments generate results correct format. Catches errors operators calls help debug code. Calculates metrics check performance, log console, stop algorithm reaches desired value.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"metrics","dir":"Articles","previous_headings":"","what":"Metrics","title":"Using the Phy Algorithm","text":"Lets talk flow_stopper flow_logger. See full help page details, flow_stopper recives list : element formula, expression LHS can access results point, ie: current iteration t time. sequences f (\\(t \\times 1\\) vector) iterations. sequence x (\\(t \\times m\\) matrix) x (\\(t \\times \\tilde{m}\\) matrix). sequence meta-information , whichever format made . , user can define metric wants. expression evaluated current context algorithm, via non-standard evaluation (, Advanced R, yes, favorite R book, knew?), using columns \\(results_t\\) variables (hence beauty matrix-columns). , RHS expression takes value metric .m returns single boolean. Finally, check_expr expression gets vector booleans (.ms) combines logical expression single boolean, TRUE algorithm stopped. allows stopping algorithm group metrics true. flow_logger similar, can also access metrics calculated variables (hence names list ), RHS function formats .m single string. Lets set . stopping criteria reaching 20 iterations. objects comprised elements used algorithm:","code":"list(   max_iter = t ~ .m >= 20,   max_time = time ~ .m >= 600,   f_prop = (max(f[[t]]) - max(f[[t - l]])) / abs(max(f[[t - 1]])) ~ .m < 0.01 ) stopper <- flow_stopper(list(max_iter = t ~ .m >= 20)) logger <- flow_logger() str(stopper) #> List of 3 #>  $ iter_upper   : num 10000 #>  $ get_metrics  :function (results, t, time)   #>  $ check_metrics:function (metrics_t, which = FALSE)   #>  - attr(*, \"class\")= chr \"flow_stopper\" str(logger) #> List of 1 #>  $ log:function (results_t, t, time, metrics_t)   #>  - attr(*, \"class\")= chr \"flow_logger\""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/example.html","id":"the-full-algorithm","dir":"Articles","previous_headings":"","what":"The Full Algorithm","title":"Using the Phy Algorithm","text":"Lets run ! can get duration, stopping criterias met, \\(R_t\\) \\(M_t\\), including best (last): can see got close global minimum \\((0, 2)\\). efficacy due number iters user code.","code":"optima <- optimize_phy(   f, g, gtil,   x_dom, xtil_dom,   initializer, optimizer, updater,   stopper, logger,   check_op = 0 ) #> → => Iter: 1 -- mean(f): 31.2683 #> → => Iter: 2 -- mean(f): 11.7562 #> → => Iter: 3 -- mean(f): 6.82 #> → => Iter: 4 -- mean(f): 6.4342 #> → => Iter: 5 -- mean(f): 6.3033 #> → => Iter: 6 -- mean(f): 6.0057 #> → => Iter: 7 -- mean(f): 5.855 #> → => Iter: 8 -- mean(f): 5.7328 #> → => Iter: 9 -- mean(f): 5.2253 #> → => Iter: 10 -- mean(f): 5.1215 #> → => Iter: 11 -- mean(f): 4.8846 #> → => Iter: 12 -- mean(f): 4.9285 #> → => Iter: 13 -- mean(f): 4.6471 #> → => Iter: 14 -- mean(f): 4.785 #> → => Iter: 15 -- mean(f): 4.7541 #> → => Iter: 16 -- mean(f): 4.5084 #> → => Iter: 17 -- mean(f): 4.72 #> → => Iter: 18 -- mean(f): 4.6569 #> → => Iter: 19 -- mean(f): 4.6255 #> → => Iter: 20 -- mean(f): 4.6122 #>  #> ✔ Finished after 20 iterations. Stopping criteria(s) were: #> • max_iter: t ~ .m >= 20 str(optima, 1) #> List of 4 #>  $ results     :List of 20 #>  $ metrics     :List of 20 #>  $ metrics_stop: Named chr \"max_iter: t ~ .m >= 20\" #>   ..- attr(*, \"names\")= chr \"max_iter\" #>  $ duration    :List of 4 optima$duration #> $iters #> [1] 20 #>  #> $time_init #> Time difference of 0.01880693 secs #>  #> $time_loop #> Time difference of 1.614986 secs #>  #> $time_total #> Time difference of 1.633796 secs optima$metrics_stop #>                 max_iter  #> \"max_iter: t ~ .m >= 20\" r_t <- optima$results[[20]] r_t[which.max(r_t$f), ] #>              x     xtil        f  i #> 5 2.053031e-06 2.259283 5.104362 NA"},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Theoretical Framework","text":"article, introduce motivation theoretical framework behind phyopt package. Consider also seeing vignette(\"example\", package = \"phyopt\") article practical example implementation explanation algorithm. literature use hybrid optimization methods using two stages firstly deal complex aspects problem, solve remaining simpler problem efficient methods. consider hybrid methods, random first step, provide space custom operators, possibly based heuristics. flexibility important solve non-standard problems. ’ll start describing problems interest rewriting language section Section 2. generalist framing, ’ll describe method’s design section Section 3, essence coding implementation Section 4.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"sec-theory","dir":"Articles","previous_headings":"","what":"Theoretical Framework","title":"Theoretical Framework","text":"’ll consider three types ‘bad-behaviors’: non-real variables domains (integer, categorical etc.); variables affect objective constraints functions complex (non-linear) way; endogenous structure – problems structure problem part optimization choice (eg. objetive function, domain, can chosen). Also consider variables separable characteristics: imply clear global optimum others don’t – \\((x + \\sin(2y))\\); convex others aren’t – \\((x^2 + \\text{floor}(x)^2)\\); ‘difficult’ constraints others don’t. going use examples economics, context doesn’t really matter, mathematical characteristics important. Consider central planner choosing lump-sum taxes \\(\\tau\\) maximize social welfare function. higher tax, higher government’s utility, smaller population’s \\(\\\\{1, 2, \\dots, N\\}\\). \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: \\mathbb{R}^+ \\\\mathbb{R} \\end{array} \\] Let’s add difficulty steps. Consider discrete nature money, mixed-integer problem: \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: [0.01, 0.02, \\dots] \\\\mathbb{R} \\end{array} \\] Suppose government can choose different taxes \\(\\tau_s\\) given person’s group \\(s_i \\\\{, B\\}\\). , problem now mixed categorical variable: \\[ \\begin{array}{lr}   \\max_{\\tau, s} u(\\tau, s) = U_G(\\tau, s) + \\sum_{= 1}^N U_P^(\\tau_i(s_i)), &   u: (\\mathbb{R}^+)^2 \\times \\{, B\\}^N \\\\mathbb{R}\\\\   \\tau_i(s_i) = \\{s_i = \\}\\tau_A + \\{s_i = B\\}\\tau_B & \\end{array} \\] central planner, choosing \\(\\tau\\), must commit interval \\([\\underline{\\tau}, \\underline{\\tau} + c]\\), \\(c \\\\mathbb{R}\\)? , maybe, number groups can chosen, \\(s \\\\{, B\\}\\) \\(\\{,B,C\\}\\), …? \\[ \\begin{array}{lr}   \\max_{\\tau, S, \\mathcal{S}} u(\\tau, S) = U_G(\\tau, S) + \\sum_{= 1}^N U_P^(\\tau_i(S_i)), &   u: (\\mathbb{R}^+)^2 \\times \\mathcal{S}^N \\\\mathbb{R}\\\\   \\max_{\\tau, \\underline{\\tau}} u(\\tau), &   u: [\\underline{\\tau}, \\underline{\\tau} + c] \\\\mathbb{R} \\end{array} \\] Additionally, consider researcher’s problem: data \\(\\tau\\) \\(u(\\tau; \\theta)\\) want estimate parameter \\(\\theta\\) minimizing loss function \\(L(\\theta; y - u(\\tau; \\theta))\\). don’t know scale abstract parameter \\(\\theta\\) must choose domain computational method choosing: \\[ \\begin{array}{lr}   \\min_{\\theta, \\Theta} L(\\theta; y - u(\\tau; \\theta)), &   L: \\Theta \\\\mathbb{R} \\end{array} \\] formulation interesting, fundamentally different using general domain creating new constraint \\(x \\\\{\\underline{\\tau}, \\underline{\\tau}+ c\\}\\). last example didn’t rule, ’ll show can rewrite way. Similar manipulations done endogeneity structure set objective function options. Consider general problem optimizing real-value function, possibly non-real domain. ’ll show alterations can done transform generalist problem, aligned hybrid methods. \\[ \\begin{array}{lr}   \\max_{x, X} f(x) ~~s.t.~~ g(x) \\geq 0, &   f: X \\\\mathbb{R}^n,~ g: X \\\\mathbb{R}^m,~ X \\\\mathcal{X} \\end{array} \\] : domain endogenous options \\(\\mathcal{X}\\); \\(n, m \\\\mathbb{N}\\) dimensions result constraints, respectively; restrictions can irrelevant \\(g(x) = 0\\); dimensions \\(x\\) need used \\(f\\) \\(g\\). First, note can always separate, full \\(x\\), variables \\(\\tilde{x}\\) worked first step. constraints depend \\(\\tilde{x}\\), can separate \\(\\tilde{g}(\\tilde{x})\\). Additionally, can map domain options \\(\\mathcal{X}\\) set indexes \\(\\tilde{X}\\). , can rewrite problem choosing index: \\[ \\begin{array}{lr}   \\max_{x, \\tilde{x}} f(x) ~~s.t.~~ g(x) \\geq 0, &   f: X_{\\tilde{x}} \\\\mathbb{R}^n,~ g: X_{\\tilde{x}} \\\\mathbb{R}^{m},~ \\tilde{x} \\\\tilde{X} \\end{array} \\] Based equivalence , can change domain options \\(\\mathcal{X}\\) restriction options \\(H_{\\mathcal{X}}\\). , can trade domain choosing constraint \\(g_{m+1}\\): \\[ \\begin{array}{c}   x \\X ~~\\Leftrightarrow~~ h(x) \\geq 0,~ h: X = \\{x: h(x) \\geq 0\\}\\\\   H_{\\mathcal{X}} = \\{h_{\\tilde{x}}: X = \\{x: h_{\\tilde{x}}(x) \\geq 0\\},~ X \\\\mathcal{X}\\}\\\\   g_{m+1}(x, \\tilde{x}) = \\sum_{\\\\tilde{X}} \\{= \\tilde{x}\\}h_{\\tilde{x}}(x) \\end{array} \\] \\(\\mathcal{X}\\) uncountable, \\(\\tilde{X} \\subseteq \\mathbb{R}\\) use integral. manipulations, reframed problem becomes: \\[ \\begin{array}{lr}     \\max_{x, \\tilde{x}} f(x, \\tilde{x}) ~~s.t.~~ g(x, \\tilde{x}) \\geq 0,~ \\tilde{g}(\\tilde{x}) \\geq 0, &     f: X \\\\mathbb{R}^n,~ g: X \\times \\tilde{X} \\\\mathbb{R}^{m},~ \\tilde{g}: \\tilde{X} \\\\mathbb{R}^{\\tilde{m}} \\end{array} \\] \\(X \\subseteq \\mathbb{R}^k\\) open \\(g: X \\rightarrow \\mathbb{R}^m\\) differentiable, KKT conditions aren’t satisfied. Thus, ’ll describe method problem next section.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"considered-problems-and-examples","dir":"Articles","previous_headings":"","what":"Considered Problems and Examples","title":"Theoretical Framework","text":"’ll consider three types ‘bad-behaviors’: non-real variables domains (integer, categorical etc.); variables affect objective constraints functions complex (non-linear) way; endogenous structure – problems structure problem part optimization choice (eg. objetive function, domain, can chosen). Also consider variables separable characteristics: imply clear global optimum others don’t – \\((x + \\sin(2y))\\); convex others aren’t – \\((x^2 + \\text{floor}(x)^2)\\); ‘difficult’ constraints others don’t. going use examples economics, context doesn’t really matter, mathematical characteristics important. Consider central planner choosing lump-sum taxes \\(\\tau\\) maximize social welfare function. higher tax, higher government’s utility, smaller population’s \\(\\\\{1, 2, \\dots, N\\}\\). \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: \\mathbb{R}^+ \\\\mathbb{R} \\end{array} \\] Let’s add difficulty steps. Consider discrete nature money, mixed-integer problem: \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: [0.01, 0.02, \\dots] \\\\mathbb{R} \\end{array} \\] Suppose government can choose different taxes \\(\\tau_s\\) given person’s group \\(s_i \\\\{, B\\}\\). , problem now mixed categorical variable: \\[ \\begin{array}{lr}   \\max_{\\tau, s} u(\\tau, s) = U_G(\\tau, s) + \\sum_{= 1}^N U_P^(\\tau_i(s_i)), &   u: (\\mathbb{R}^+)^2 \\times \\{, B\\}^N \\\\mathbb{R}\\\\   \\tau_i(s_i) = \\{s_i = \\}\\tau_A + \\{s_i = B\\}\\tau_B & \\end{array} \\] central planner, choosing \\(\\tau\\), must commit interval \\([\\underline{\\tau}, \\underline{\\tau} + c]\\), \\(c \\\\mathbb{R}\\)? , maybe, number groups can chosen, \\(s \\\\{, B\\}\\) \\(\\{,B,C\\}\\), …? \\[ \\begin{array}{lr}   \\max_{\\tau, S, \\mathcal{S}} u(\\tau, S) = U_G(\\tau, S) + \\sum_{= 1}^N U_P^(\\tau_i(S_i)), &   u: (\\mathbb{R}^+)^2 \\times \\mathcal{S}^N \\\\mathbb{R}\\\\   \\max_{\\tau, \\underline{\\tau}} u(\\tau), &   u: [\\underline{\\tau}, \\underline{\\tau} + c] \\\\mathbb{R} \\end{array} \\] Additionally, consider researcher’s problem: data \\(\\tau\\) \\(u(\\tau; \\theta)\\) want estimate parameter \\(\\theta\\) minimizing loss function \\(L(\\theta; y - u(\\tau; \\theta))\\). don’t know scale abstract parameter \\(\\theta\\) must choose domain computational method choosing: \\[ \\begin{array}{lr}   \\min_{\\theta, \\Theta} L(\\theta; y - u(\\tau; \\theta)), &   L: \\Theta \\\\mathbb{R} \\end{array} \\] formulation interesting, fundamentally different using general domain creating new constraint \\(x \\\\{\\underline{\\tau}, \\underline{\\tau}+ c\\}\\). last example didn’t rule, ’ll show can rewrite way. Similar manipulations done endogeneity structure set objective function options.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"different-natures-of-variables","dir":"Articles","previous_headings":"Theoretical Framework","what":"Different Natures of Variables","title":"Theoretical Framework","text":"Also consider variables separable characteristics: imply clear global optimum others don’t – \\((x + \\sin(2y))\\); convex others aren’t – \\((x^2 + \\text{floor}(x)^2)\\); ‘difficult’ constraints others don’t. going use examples economics, context doesn’t really matter, mathematical characteristics important.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"non-real-valued-variables","dir":"Articles","previous_headings":"Theoretical Framework","what":"Non Real-Valued Variables","title":"Theoretical Framework","text":"Consider central planner choosing lump-sum taxes \\(\\tau\\) maximize social welfare function. higher tax, higher government’s utility, smaller population’s \\(\\\\{1, 2, \\dots, N\\}\\). \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: \\mathbb{R}^+ \\\\mathbb{R} \\end{array} \\] Let’s add difficulty steps. Consider discrete nature money, mixed-integer problem: \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: [0.01, 0.02, \\dots] \\\\mathbb{R} \\end{array} \\] Suppose government can choose different taxes \\(\\tau_s\\) given person’s group \\(s_i \\\\{, B\\}\\). , problem now mixed categorical variable: \\[ \\begin{array}{lr}   \\max_{\\tau, s} u(\\tau, s) = U_G(\\tau, s) + \\sum_{= 1}^N U_P^(\\tau_i(s_i)), &   u: (\\mathbb{R}^+)^2 \\times \\{, B\\}^N \\\\mathbb{R}\\\\   \\tau_i(s_i) = \\{s_i = \\}\\tau_A + \\{s_i = B\\}\\tau_B & \\end{array} \\]","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"endogenous-structure","dir":"Articles","previous_headings":"Theoretical Framework","what":"Endogenous Structure","title":"Theoretical Framework","text":"central planner, choosing \\(\\tau\\), must commit interval \\([\\underline{\\tau}, \\underline{\\tau} + c]\\), \\(c \\\\mathbb{R}\\)? , maybe, number groups can chosen, \\(s \\\\{, B\\}\\) \\(\\{,B,C\\}\\), …? \\[ \\begin{array}{lr}   \\max_{\\tau, S, \\mathcal{S}} u(\\tau, S) = U_G(\\tau, S) + \\sum_{= 1}^N U_P^(\\tau_i(S_i)), &   u: (\\mathbb{R}^+)^2 \\times \\mathcal{S}^N \\\\mathbb{R}\\\\   \\max_{\\tau, \\underline{\\tau}} u(\\tau), &   u: [\\underline{\\tau}, \\underline{\\tau} + c] \\\\mathbb{R} \\end{array} \\] Additionally, consider researcher’s problem: data \\(\\tau\\) \\(u(\\tau; \\theta)\\) want estimate parameter \\(\\theta\\) minimizing loss function \\(L(\\theta; y - u(\\tau; \\theta))\\). don’t know scale abstract parameter \\(\\theta\\) must choose domain computational method choosing: \\[ \\begin{array}{lr}   \\min_{\\theta, \\Theta} L(\\theta; y - u(\\tau; \\theta)), &   L: \\Theta \\\\mathbb{R} \\end{array} \\] formulation interesting, fundamentally different using general domain creating new constraint \\(x \\\\{\\underline{\\tau}, \\underline{\\tau}+ c\\}\\). last example didn’t rule, ’ll show can rewrite way. Similar manipulations done endogeneity structure set objective function options.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"reframing-the-problems","dir":"Articles","previous_headings":"","what":"Reframing the Problems","title":"Theoretical Framework","text":"Consider general problem optimizing real-value function, possibly non-real domain. ’ll show alterations can done transform generalist problem, aligned hybrid methods. \\[ \\begin{array}{lr}   \\max_{x, X} f(x) ~~s.t.~~ g(x) \\geq 0, &   f: X \\\\mathbb{R}^n,~ g: X \\\\mathbb{R}^m,~ X \\\\mathcal{X} \\end{array} \\] : domain endogenous options \\(\\mathcal{X}\\); \\(n, m \\\\mathbb{N}\\) dimensions result constraints, respectively; restrictions can irrelevant \\(g(x) = 0\\); dimensions \\(x\\) need used \\(f\\) \\(g\\). First, note can always separate, full \\(x\\), variables \\(\\tilde{x}\\) worked first step. constraints depend \\(\\tilde{x}\\), can separate \\(\\tilde{g}(\\tilde{x})\\). Additionally, can map domain options \\(\\mathcal{X}\\) set indexes \\(\\tilde{X}\\). , can rewrite problem choosing index: \\[ \\begin{array}{lr}   \\max_{x, \\tilde{x}} f(x) ~~s.t.~~ g(x) \\geq 0, &   f: X_{\\tilde{x}} \\\\mathbb{R}^n,~ g: X_{\\tilde{x}} \\\\mathbb{R}^{m},~ \\tilde{x} \\\\tilde{X} \\end{array} \\] Based equivalence , can change domain options \\(\\mathcal{X}\\) restriction options \\(H_{\\mathcal{X}}\\). , can trade domain choosing constraint \\(g_{m+1}\\): \\[ \\begin{array}{c}   x \\X ~~\\Leftrightarrow~~ h(x) \\geq 0,~ h: X = \\{x: h(x) \\geq 0\\}\\\\   H_{\\mathcal{X}} = \\{h_{\\tilde{x}}: X = \\{x: h_{\\tilde{x}}(x) \\geq 0\\},~ X \\\\mathcal{X}\\}\\\\   g_{m+1}(x, \\tilde{x}) = \\sum_{\\\\tilde{X}} \\{= \\tilde{x}\\}h_{\\tilde{x}}(x) \\end{array} \\] \\(\\mathcal{X}\\) uncountable, \\(\\tilde{X} \\subseteq \\mathbb{R}\\) use integral. manipulations, reframed problem becomes: \\[ \\begin{array}{lr}     \\max_{x, \\tilde{x}} f(x, \\tilde{x}) ~~s.t.~~ g(x, \\tilde{x}) \\geq 0,~ \\tilde{g}(\\tilde{x}) \\geq 0, &     f: X \\\\mathbb{R}^n,~ g: X \\times \\tilde{X} \\\\mathbb{R}^{m},~ \\tilde{g}: \\tilde{X} \\\\mathbb{R}^{\\tilde{m}} \\end{array} \\] \\(X \\subseteq \\mathbb{R}^k\\) open \\(g: X \\rightarrow \\mathbb{R}^m\\) differentiable, KKT conditions aren’t satisfied. Thus, ’ll describe method problem next section.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"sec-design","dir":"Articles","previous_headings":"","what":"Method Design","title":"Theoretical Framework","text":"First, one must define: number \\(T \\\\mathbb{N}\\) iterations (denoted \\(t\\)); number \\(N \\\\mathbb{N}\\) samples (denoted \\(s\\)) population \\(S_t\\). Denote step \\(S_0 = \\text{init}(\\tilde{X}, \\tilde{g})\\). first step create initial population separated variables \\(\\tilde{x}\\), \\(S_0 = (\\tilde{x}_s)_{s = 1}^N\\). population must created respect constraints \\(\\tilde{g}\\). Denote step \\(S_0 = \\text{initialize}(\\tilde{X}, \\tilde{g})\\). several methods create initial sample. generally can divided : One can use uniform distribution, heuristic guess based knowledge problem, -la importance sampling. Examples grid sampling, Latin Hypercube sampling, Kronecker sampling, Sobol Halton sequences. Additionally, domain can split groups sampling done within group (stratified/cluster-based sampling). main goal guarantee algorithm able explore whole domain. Kazimipour et. al. (2014) provides comprehensive review initialization methods. , guarantee validity \\(\\tilde{g}\\) constraints, also several methods: Using closest valid point, projection valid space, amongst others. Sampling dimension \\(\\tilde{x}_s\\) time, updating valid space rest time; choosing distribution \\(P\\) likely sample valid points; amongst others. Note \\(\\tilde{x}\\) contains encoded variables, Researcher’s Problem, heuristics used depend encoding done. Denote step \\(R_t = \\text{optimize}(X, g, t, S_t)\\). given sample \\(\\tilde{x}_s\\), left reduced problem, doesn’t depend \\(\\tilde{x}\\) \\(\\tilde{g}\\): \\[ \\begin{array}{lr}   \\max_{x} f_s(x;~ \\tilde{x}_s) ~~s.t.~~ g_s(x;~ \\tilde{x}_s) \\geq 0, &   f: X \\\\mathbb{R}^n,~ g: X \\\\mathbb{R}^m \\end{array} \\] One chooses solver liking problem. One can also choose several options, get randomly picked sample, helps generality solution. , \\(\\tilde{x}_s \\S_t\\), problem solved \\(x_s^*\\), ordered set results - optional meta-information \\(I_s\\) (e.g.: time completion) - stored: \\[ \\begin{array}{lr}   O_s = (\\tilde{x}_s,~ x^*_s,~ f(x^*_s, \\tilde{x}_s),~ I_s), &   R_t = (O_s)_{s = 1}^N \\end{array} \\] set metrics \\(M_t\\) calculated \\(R_t\\). , stopping criteria can drawn combination options. top maximum time elapsed iterations, one can consider best/median/sample value \\((\\tilde{x}, x)\\) performance \\(f((\\tilde{x}, x))\\) (denote \\(o\\)), via: threshold \\(o \\gtrless k\\); convergence \\(|o_{t'} - o_t| < \\epsilon\\); stability \\(sd(o) < \\epsilon\\). Let \\(R = (R_t)_{t = 1}^T\\) \\(M = (M_t)_{t = 1}^T\\). last step update sample: \\(S_{t+1} = \\text{update}(\\tilde{X}, \\tilde{g}, t, S_t, R_t)\\). general objective create new population “direction” best performing samples \\(S_t\\). many literatures motivate \\(\\text{update}\\) operators, user-supplied coding implementation, setup can encompass many options. present explanation, ’ll focus operators easily applied numeric problems economics, mainly related Evolutionary Algorithms literature. Consider option combining random tuples samples (“crossover”), adding randomization, avoid local optima (“mutation”). simplistic terms, ‘child’ sample created : Position crossover: taking positions/dimensions ‘parents’, randomly. Arithmetic crossover: combining parents’ values, averages else. Distributional crossover: sampling distribution based parents’ values. Resample mutation: randomly choosing dimension resample distribution. Noise mutation: randomly choosing dimension add noise. amount crossover mutation, amongst others, can hyperparameters, can even depend iteration \\(t\\). , remotely exhaustive list. crossover mutation can found Kora Yadlapalli (2017), De Falco et. al. (2002), many random optimization literatures can considered. Note operators need account possibly non-real non-numeric variables, also constraints \\(\\tilde{g}\\). flexibility able define operator major advantage method.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"first-step-create-initial-sample-of-tildex","dir":"Articles","previous_headings":"","what":"First Step: Create Initial Sample of \\(\\tilde{x}\\)","title":"Theoretical Framework","text":"first step create initial population separated variables \\(\\tilde{x}\\), \\(S_0 = (\\tilde{x}_s)_{s = 1}^N\\). population must created respect constraints \\(\\tilde{g}\\). Denote step \\(S_0 = \\text{initialize}(\\tilde{X}, \\tilde{g})\\). several methods create initial sample. generally can divided : One can use uniform distribution, heuristic guess based knowledge problem, -la importance sampling. Examples grid sampling, Latin Hypercube sampling, Kronecker sampling, Sobol Halton sequences. Additionally, domain can split groups sampling done within group (stratified/cluster-based sampling). main goal guarantee algorithm able explore whole domain. Kazimipour et. al. (2014) provides comprehensive review initialization methods. , guarantee validity \\(\\tilde{g}\\) constraints, also several methods: Using closest valid point, projection valid space, amongst others. Sampling dimension \\(\\tilde{x}_s\\) time, updating valid space rest time; choosing distribution \\(P\\) likely sample valid points; amongst others. Note \\(\\tilde{x}\\) contains encoded variables, Researcher’s Problem, heuristics used depend encoding done.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"second-step-solve-the-reduced-problem","dir":"Articles","previous_headings":"","what":"Second Step: Solve the Reduced Problem","title":"Theoretical Framework","text":"Denote step \\(R_t = \\text{optimize}(X, g, t, S_t)\\). given sample \\(\\tilde{x}_s\\), left reduced problem, doesn’t depend \\(\\tilde{x}\\) \\(\\tilde{g}\\): \\[ \\begin{array}{lr}   \\max_{x} f_s(x;~ \\tilde{x}_s) ~~s.t.~~ g_s(x;~ \\tilde{x}_s) \\geq 0, &   f: X \\\\mathbb{R}^n,~ g: X \\\\mathbb{R}^m \\end{array} \\] One chooses solver liking problem. One can also choose several options, get randomly picked sample, helps generality solution. , \\(\\tilde{x}_s \\S_t\\), problem solved \\(x_s^*\\), ordered set results - optional meta-information \\(I_s\\) (e.g.: time completion) - stored: \\[ \\begin{array}{lr}   O_s = (\\tilde{x}_s,~ x^*_s,~ f(x^*_s, \\tilde{x}_s),~ I_s), &   R_t = (O_s)_{s = 1}^N \\end{array} \\] set metrics \\(M_t\\) calculated \\(R_t\\). , stopping criteria can drawn combination options. top maximum time elapsed iterations, one can consider best/median/sample value \\((\\tilde{x}, x)\\) performance \\(f((\\tilde{x}, x))\\) (denote \\(o\\)), via: threshold \\(o \\gtrless k\\); convergence \\(|o_{t'} - o_t| < \\epsilon\\); stability \\(sd(o) < \\epsilon\\). Let \\(R = (R_t)_{t = 1}^T\\) \\(M = (M_t)_{t = 1}^T\\).","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"third-step-update-the-sample","dir":"Articles","previous_headings":"","what":"Third Step: Update the Sample","title":"Theoretical Framework","text":"last step update sample: \\(S_{t+1} = \\text{update}(\\tilde{X}, \\tilde{g}, t, S_t, R_t)\\). general objective create new population “direction” best performing samples \\(S_t\\). many literatures motivate \\(\\text{update}\\) operators, user-supplied coding implementation, setup can encompass many options. present explanation, ’ll focus operators easily applied numeric problems economics, mainly related Evolutionary Algorithms literature. Consider option combining random tuples samples (“crossover”), adding randomization, avoid local optima (“mutation”). simplistic terms, ‘child’ sample created : Position crossover: taking positions/dimensions ‘parents’, randomly. Arithmetic crossover: combining parents’ values, averages else. Distributional crossover: sampling distribution based parents’ values. Resample mutation: randomly choosing dimension resample distribution. Noise mutation: randomly choosing dimension add noise. amount crossover mutation, amongst others, can hyperparameters, can even depend iteration \\(t\\). , remotely exhaustive list. crossover mutation can found Kora Yadlapalli (2017), De Falco et. al. (2002), many random optimization literatures can considered. Note operators need account possibly non-real non-numeric variables, also constraints \\(\\tilde{g}\\). flexibility able define operator major advantage method.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/articles/theoretical_framework.html","id":"sec-implementation","dir":"Articles","previous_headings":"","what":"Coding Implementation","title":"Theoretical Framework","text":"unfeasible explain details implementation , explained package’s documentation. main function optimize_phy(). , others, documentation pages math notation , similar argument names (e.g.: xtil \\(\\tilde{x}\\) x_dom \\(X\\)). function receives main arguments: functions f, g, gtil, must receive correct arguments x /xtil. domains x_dom, xtil_dom, lists length \\(m\\) \\(\\tilde{m}\\). used user-supplied operators elements can whatever user needs. operators initializer, optimizer, updater, must receive arguments described previous section, return output specific format. helper stopper, calculates metrics performance iteration, sets stopping criteria; logger, logs performance console user feedback. created helper functions flow_stopper() flow_logger(). algorithm presented . user-provided function calls wrapped try_op function, catch notify errors user-friendly way. notation x\\$y indicates object \\(y\\) within object \\(x\\).  important read “Using Phy Algorithm” vignette vignette(\"example\", package = \"phyopt\"), thoroughly explains package logic usage. core, wrapper ‘organize’ operators two-step hybrid procedure. user ‘responsibility’ making smart choices operators, package guarantees () thorough tests error handling help debugging, (ii) flexible/generalist/agnostic setup, doesn’t restrict user. tricks allow () size \\(m\\) \\(\\tilde{m}\\); (ii) kind operator; (iii) kind metric \\(M_t\\) stopping criteria specially important.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ricardo Semião. Author, maintainer.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Semião R (2025). phyopt: General-Use Population-Based Hybrid Optimization. R package version 0.0.0.9000, https://ricardo-semiao.github.io/phyopt/, https://https://github.com/ricardo-semiao/phyopt.","code":"@Manual{,   title = {phyopt: General-Use Population-Based Hybrid Optimization},   author = {Ricardo Semião},   year = {2025},   note = {R package version 0.0.0.9000,     https://ricardo-semiao.github.io/phyopt/},   url = {https://https://github.com/ricardo-semiao/phyopt}, }"},{"path":"https://ricardo-semiao.github.io/phyopt/index.html","id":"phyopt","dir":"","previous_headings":"","what":"General-Use Population-Based Hybrid Optimization","title":"General-Use Population-Based Hybrid Optimization","text":"packages implements two-step, population-based, hybrid optimization algorithm, solving problems form: \\[ \\begin{array}{c}   \\max_{x, \\tilde{x}} f(x, \\tilde{x}) ~~s.t.~~ g(x, \\tilde{x}) \\geq 0,~ \\tilde{g}(\\tilde{x}) \\geq 0,\\\\   x \\X,~ \\tilde{x} \\\\tilde{X} \\end{array} \\] paper fully describing motivation, theoretical framework, method design available vignette(\"theoretical_framework\", package = \"phyopt\"). now, see vignette vignette(\"example\", package = \"phyopt\"), contains simple example thorough explanation package works. Additionally, see documentation optimize_phy() function, main function package Disclaimer: package early stage life. hasn’t thoroughly tested can present several bugs. don’t recommend using large-scale projects, yet. Please report problems GitHub issue. comments can posted GitHub discussion, sent email . Thank ! Author: Ricardo Semião e Castro (ricardo.semiao@outlook).","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"General-Use Population-Based Hybrid Optimization","text":"can install development version phyopt like :","code":"# install.packages(\"devtools\") devtools::install_github(\"ricardo-semiao/phyopt\")"},{"path":"https://ricardo-semiao.github.io/phyopt/index.html","id":"development-comments","dir":"","previous_headings":"","what":"Development Comments","title":"General-Use Population-Based Hybrid Optimization","text":"package young, puts much responsibility optimization user. said , think decently solid. implement tests run examples, figure already stable. features plan add future: testthat package structure created package, haven’t time write unir tests yet. Add complicated examples vignette(\"example\", package = \"phyopt\"). Expand suggested metrics get_metrics, also add suggestions formatters logger object. Add suggested operators optimize_phy(), common initializers, optimizers, updaters literature. Add .exit() call optimize_pbhy(), safely returns reaching eventual error. Create summary() plot() methods optimize_pbhy() result. Note package: Using styler lintr packages style consistency. Uses testthat 3 automate tests. Uses rlang frameworks tidy eval rlang errors.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 phyopt authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_logger.html","id":null,"dir":"Reference","previous_headings":"","what":"Flow Logger Constructor — flow_logger","title":"Flow Logger Constructor — flow_logger","text":"function creates flow logger object calculates metrics logs console. metrics definition done similarly flow_stopper() function (see help page), formulas divided lists, list printed different line.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_logger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flow Logger Constructor — flow_logger","text":"","code":"flow_logger(   formulas_list = list(list(t ~ paste(\"=> Iter:\", .m), mean(f) ~ paste(\"mean(f):\",     round(.m, 4)))),   log_each = 1,   sep = \" -- \",   args_alert = list(),   args_ul = list() )"},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_logger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flow Logger Constructor — flow_logger","text":"formulas_list list formulas flow_stopper() (list lists), except RHS function takes LHS value .m returns single string printed. log_each integer specifying frequency logging. sep character string used concatenate logs associated list inside formulas_list. args_alert, args_ul list arguments passed cli::cli_alert() cli::cli_ul(), functions format console output.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_logger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flow Logger Constructor — flow_logger","text":"\"flow_logger\"-class object passed optimize_phy().","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_logger.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Flow Logger Constructor — flow_logger","text":"LHS formulas evaluated way flow_stopper() (see help page), user access current results (\\(R_t\\)). Additionally, metric current iteration (\\(M_t\\)) can accessed name (formulas named).","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_stopper.html","id":null,"dir":"Reference","previous_headings":"","what":"Flow Stopper Constructor — flow_stopper","title":"Flow Stopper Constructor — flow_stopper","text":"function creates flow stopper object calculate metrics, iteration, based current results algorithm, checks algorithm stop based metrics. Given objects \\(R\\) (list results every iteration), user can define set metrics \\(M_t\\), calculated every iteration \\(t\\). Based metric\\(m\\), stopping criterion can defined via expression \\(m\\) returns boolean. Finally, list booleans given iteration \\(t\\) can combined logic expression determine algorithm stop.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_stopper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flow Stopper Constructor — flow_stopper","text":"","code":"flow_stopper(   formulas = list(get_metric$iter(100), get_metric$f_prop(0.01)),   check_expr = ~any(.ms, na.rm = TRUE),   iter_upper = 10000 )"},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_stopper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flow Stopper Constructor — flow_stopper","text":"formulas list formulas specifying metrics \\(m\\) calculated LHS (see details), stopping criterion depending metric value .m, RHS. check_expr RHS-formula logic operation, depending vector booleans .ms. iter_upper technical argument used initialize containers \\(R\\) \\(M\\). stopping criterion based \\(t\\) defined formulas argument.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_stopper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flow Stopper Constructor — flow_stopper","text":"\"flow_stopper\"-class object passed optimize_phy().","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/flow_stopper.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Flow Stopper Constructor — flow_stopper","text":"LHS evaluated context algorithm, .e., can depend variables t (current iteration), time (current time seconds), list element \\(R\\) (length t). example, f[[t - 1]] evaluate vector objective function values samples previous iteration. Note can set unfeasible stopping criteria, FALSE get value metric end algorithm.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/get_metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Get common metrics' formulas — get_metric","title":"Get common metrics' formulas — get_metric","text":"Get common metrics' formulas","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/get_metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get common metrics' formulas — get_metric","text":"","code":"get_metric"},{"path":"https://ricardo-semiao.github.io/phyopt/reference/get_metric.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Get common metrics' formulas — get_metric","text":"object class list length 2.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/optimize_phy.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"function implements two-step, population-based, hybrid optimization  algorithm, solving problems form: \\[ \\begin{array}{c} \\max_{x, \\tilde{x}} f(x, \\tilde{x}) ~~s.t.~~ g(x, \\tilde{x}) \\geq 0, ~ \\tilde{g}(\\tilde{x}) \\geq 0,\\ x \\X,~ \\tilde{x} \\\\tilde{X} \\end{array} \\] See readme details format problems, pb-hy  algorithm useful.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/optimize_phy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"","code":"optimize_phy(   f = function(x, xtil) NA,   g = function(x, xtil) 0,   gtil = function(xtil) 0,   x_dom,   xtil_dom,   initializer,   optimizer,   updater,   stopper = flow_stopper(),   logger = flow_logger(),   check_samples = NULL,   check_op = c(1, 2) )"},{"path":"https://ricardo-semiao.github.io/phyopt/reference/optimize_phy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"f Objective function \\(f(x, \\tilde{x})\\). g, gtil Constraint functions \\(g(x, \\tilde{x})\\) \\(\\tilde{g}(\\tilde{x})\\). default, never-binding ones. x_dom, xtil_dom Domains \\(X\\) \\(\\tilde{X}\\). used `optimizer` (\\(X\\)), `initializer`/`updater` (\\(\\tilde{X}\\)). list \\(m\\) \\(\\tilde{m}\\) entries. initializer Operator (function) initialize population, \\(S_0 = \\text{initializer}(\\tilde{X}, \\tilde{g})\\) (see details). optimizer Operator (function) solve reduced problem, \\(R_t = \\text{optimizer}(X, g, t, S_t)\\) (see details). updater Operator (function) update population, \\(S_{t+1} = \\text{updater}(\\tilde{X}, \\tilde{g}, t, S_t, R_t)\\). stopper Stopping criteria algorithm, created via [flow_stopper()]. logger Logger tracking process, created via [flow_logger()]. check_samples Number samples expected \\(S_t\\). Set `NULL` check (required changes iterations \\(t\\)). check_op Integer vector iterations check operators producing results needed format. Helps catching errors. Set `0` check.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/optimize_phy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"list containing: results Optimization results iteration. metrics Metrics calculated optimization process. duration Timing information initialization, main loop, total  execution.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/optimize_phy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"function wrapper operator functions, organizing  correct structure population-based, two-step, hybrid algorithm. ,  job user implement operators correctly: * `initializer`: todo. * `optimizer`: todo. * `updater`: todo.","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/reference/phyopt-package.html","id":null,"dir":"Reference","previous_headings":"","what":"phyopt: General-Use Population-Based Hybrid Optimization — phyopt-package","title":"phyopt: General-Use Population-Based Hybrid Optimization — phyopt-package","text":"todo.","code":""},{"path":[]},{"path":"https://ricardo-semiao.github.io/phyopt/reference/phyopt-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"phyopt: General-Use Population-Based Hybrid Optimization — phyopt-package","text":"Maintainer: Ricardo Semião ricardo.semiao@outlook.com","code":""},{"path":"https://ricardo-semiao.github.io/phyopt/news/index.html","id":"phyopt-development-version","dir":"Changelog","previous_headings":"","what":"phyopt (development version)","title":"phyopt (development version)","text":"Initiated development package.","code":""}]
